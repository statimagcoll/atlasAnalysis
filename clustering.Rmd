---
title: "Clustering"
author: "Simon Vandekar"
date: "10/26/2020"
output: html_document
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::knit_hooks$set(GPs=function(before, options, envir){
  if (before){
    cex=1.5
    par(mgp=c(2.2,0.8,0), lwd=1.5, lend=2,
        cex.lab=0.8*cex, cex.axis=0.8*cex, cex.main=1*cex,
        mar=c(8,4,1.8,0), bty='l', oma=c(0,0,0,0))}
})
knitr::opts_chunk$set(echo = FALSE, fig.height = 4, fig.width = 4, GPs=TRUE, cache=FALSE, cache.lazy = FALSE, message=FALSE, warning=FALSE)

### LIBRARIES ###
library(lme4) # lmer, glmer
library(lmerTest) # tests for lme4
library(emmeans) # emmeans and emtrends
library(raster)
library(sjPlot)
library(parallel)
library(ggplot2)
library(RColorBrewer)
library(dplyr)
library(randomForest)
#devtools::install_github('statimagcoll/multiplexMoran')
#library(multiplexMoran)
library(Giotto)
set.seed(1234)
library(viridis)


# graphical and computing parameters
cols = brewer.pal(n=8, name='Set1')
transpcols = col2rgb(cols)
transpcols = rgb(transpcols[1,], transpcols[2,], transpcols[3,], maxColorValue = 255, alpha = 127)
colscale = c('#f0f9e8', '#ccebc5', '#a8ddb5','#7bccc4','#4eb3d3', '#2b8cbe', '#08589e')
ncores = 24

# color scale for displaying images
grayscale_colors <- gray.colors(100,            # number of different color levels
                                start = 0.0,    # how black (0) to go
                                end = 1.0,      # how white (1) to go
                                gamma = 2.2,    # correction between how a digital
                                # camera sees the world and how human eyes see it
                                alpha = NULL)   #Null = colors are not transparent
```

# Introduction

This report explores methods for spatial analysis. Qi suggested using the Giotto package. There's also some code testing the use of Moran's I to quantify spatial relationships between markers and cell types.


# Methods


## Data


```{r setMarkers}
# list of markers to consider
#structuralMarkers = c('PCNA', 'PANCK', 'COLLAGEN', 'VIMENTIN', 'SOX9', 'NAKATPASE')
#immuneMarkers = c('CD3D', 'CD8', 'CD4', 'CD68')
# allMarkers = c("DAPI", "VIMENTIN","SMA","CD3D","CD4","CD8","CD68","CD11B","PANCK","NAKATPASE", 'COLLAGEN', 'PCNA', 'SOX9')
allMarkers <- c("BCATENIN"  ,"CD20"    ,  "CD3D"    ,  "CD4"     ,  "CD45"     , "CD68"   ,   "CD8"     ,  "CGA" ,    "COLLAGEN" , "ERBB2"   ,  "FOXP3"   ,  "HLAA"   ,   "LYSOZYME" , "MUC2", "NAKATPASE" ,"OLFM4"   ,  "PANCK"   ,  "PCNA"    ,  "PEGFR"   ,  "PSTAT3"   , "SMA", "SOX9" ,     "VIMENTIN" , "GACTIN"  ,  "CDX2"   ,   "MUC5AC"   )
giottoMarkers = c("VIMENTIN","SMA","CD3D","CD4","CD8","CD68","CD11B","PANCK","NAKATPASE", 'COLLAGEN', 'PCNA', 'SOX9')
```


### Cell-level data

Load in quantified cell-level data.

```{r loadData, message=FALSE, warning=FALSE, fig.height=24, fig.width=8}
# An R package that loads the cell level data set from the server
#devtools::install_github('statimagcoll/atlasAnalysis')
sc = atlasAnalysis::loadQuantifiedPCA()
tts = read.csv('/media/disk2/atlas_mxif/data/TissueSubTypes Colon Map.csv')
# match capitalization
names(tts)[1] = 'TissueID'
tts$adenSSLcrc = ifelse(tts$tissueSubType %in% c('Tub', 'TV'), 'AD', 
                        ifelse(tts$tissueSubType %in% c('HP', 'HP/SSL', 'SSL', 'Tub/SSL'), 'SSL', 
                               ifelse(tts$tissueSubType %in% c('CRC'), 'CRC', NA )) )
tts$SlideID = sc$SlideID[match(tts$TissueID, sc$TissueID)]
tts = tts[,c('SlideID', 'adenSSLcrc')]
sc = merge(sc, tts, all.x=TRUE)


## SUBSETS THE DATA to tumor region and particular tissue types
sc = sc[ sc$lessBroad %in% c('AD', 'SSL', 'HP'),]
#sc = sc[ sc$Tumor>0,]
sc$MAPID = gsub('HTA11_', 'MAP', sc$SlideID)
```

### Image level data

```{r loadImageData}
### CREATES ANOTHER DATASET THAT CONTAINS THE IMAGES
#combine the csv files
allMarkers <- c("BCATENIN"  ,"CD20"    ,  "CD3D"    ,  "CD4"     ,  "CD45"     , "CD68"   ,   "CD8"     ,  "CGA" ,    "COLLAGEN" , "ERBB2"   ,  "FOXP3"   ,  "HLAA"   ,   "LYSOZYME" , "MUC2", "NAKATPASE" ,"OLFM4"   ,  "PANCK"   ,  "PCNA"    ,  "PEGFR"   ,  "PSTAT3"   , "SMA", "SOX9" ,     "VIMENTIN" , "GACTIN"  ,  "CDX2"   ,   "MUC5AC"   )
sr = atlasAnalysis::loadImagingData(unique(sc$Slide_Region), allMarkers)

# add tissue category
sr$broadTissue = factor(sc$broadTissue[ match(sr$slide_region, sc$Slide_Region)])
```

## Quality checks


```{r CellRatioCheck, eval=FALSE}
sr[,allMarkers] = apply(sr[,allMarkers], 2, function(x) gsub('\\.jpg$', '_downsampled.tif',x) )

sr$epiVol = apply(sr[,allMarkers], 1, function(vec){
  tryCatch({mat = getValues(stack(c(vec[c('NAKATPASE', 'VIMENTIN', 'PANCK', 'DAPI')])))
  mat = mat[mat[,'DAPI']>5,c('NAKATPASE', 'VIMENTIN', 'PANCK')]
  kmRes = kmeans(mat, 2)
  epiVol = sum(kmRes$cluster==which.max(kmRes$centers %*% c(1,-1,1)))
  epiVol}, error=function(e) NA )
})

epiCells = c(by(sc$epi, sc$Slide_Region, sum))
sr$epiCells = epiCells[match(sr$slide_region, names(epiCells))]
sr$ratio = sr$epiCells/sr$epiVol
sr = sr[order(sr$broadTissue),]
barplot(sr$epiCells/sr$epiVol, names.arg=gsub('region_', '', sr$slide_region), col=as.numeric(as.factor(sr$broadTissue)), las=2)
t.test(sr$epiCells/sr$epiVol ~ as.factor(sr$broadTissue))
#reactable::reactable(sr[, c('slide_region', 'broadTissue', 'ratio')])
knitr::kable(sr[, c('slide_region', 'broadTissue', 'ratio')])
```







```{r QiSeuratCode,results="asis", warning=FALSE,message=FALSE, fig.width=12, echo=FALSE, comment=FALSE, eval=FALSE}

library(ggplot2)
library(Seurat)
library(dplyr)


ProcessRegion<-function(markers, coords) {
  exp<-t(markers)
  # subsets to markers that do not have NAs
  #exp<-exp[apply(exp,1,function(x){sum(is.na(x))})==0,]
  
  # performs log2(x+1) transformation
  exp<-log2(exp+1)
  colnames(exp)<-1:dim(exp)[2]
  rownames(exp)<-gsub("Median_Cell_","",rownames(exp))
  
  obj<-CreateSeuratObject(counts=exp)
  obj<-ScaleData(obj,features=rownames(obj),verbose=F)
  obj<-FindNeighbors(obj,features=rownames(obj),dims=NULL)
  
  obj<-FindClusters(obj,verbose = F)
  
  obj<-RunUMAP(obj,features=rownames(obj))
  obj[["x"]]<-regiondata$Cell_Centroid_X
  obj[["y"]]<-regiondata$Cell_Centroid_Y
  
  
  markers<-FindAllMarkers(obj)
  obj@misc$markers<-markers
  top5<-markers %>% group_by(cluster) %>% top_n(5,avg_logFC)
  p1<-DoHeatmap(obj,features=top5$gene)+NoLegend()
  p2<-DimPlot(obj,label=T)+NoLegend()
  
  p3<-ggplot(regiondata,aes(x=Cell_Centroid_X,y=Cell_Centroid_Y,color=obj@active.ident))+geom_point(size=1)+NoLegend()
  
  print(p1+p2+p3)
  return(obj)
}

mxIFdata<-readRDS("/Users/qiliu/Dropbox (VUMC)/PCA/Spatial/MxIF/colon map batch 1-3 position corrected w immune labels.rds")
result<-list()
Slides<-unique(mxIFdata$SlideID)

for (sind in 2:3) {
  slidedata<-mxIFdata[mxIFdata$SlideID==Slides[sind],]
  cat(paste("\n\n##", Slides[sind],"\n\n"))
  Pos<-unique(slidedata$Pos)
  for (pind in 1:length(Pos)) {
    regiondata<-slidedata[slidedata$Pos==Pos[pind],]
    cat(paste("\n\n###", Pos[pind],"\n\n"))
    if (dim(regiondata)[1]>100) {
      result<-c(result,ProcessRegion(regiondata)) }
  }
}
```







## Spatial analysis using Giotto

```{r giottoSetup, echo=FALSE, results='hide'}

cellAllMarkers = paste0('Median_Cell_', allMarkers)
cellGiottoMarkers <- (names(sc)[grep("Median_Cell_", names(sc))])[-3]
# cellGiottoMarkers = paste0('Median_Cell_', giottoMarkers)
# Giotto setup. Needed to remove version numbers to get this to install properly
# installGiottoEnvironment(packages_to_install = c("pandas", "networkx", "python-igraph",
#                                                 "leidenalg", "python-louvain", "python.app", "scikit-learn", 'pytz'),
# force_environment = TRUE)
## to install packages in miniconda version of python. Seurat needs pytz
# reticulate::py_install('pytz')
```



### HTA batch Giotto clustering

ACTININ, COX2, SNA, DAPI, CD45B and PDL1 are removed from the data because of substantial number of NAs. 
```{r}
HTA.slide <- unique(sc$Slide_Region)[grep("HTA", unique(sc$Slide_Region))]
sc_HTA <- sc[(sc$Slide_Region %in% HTA.slide),]
summary(sc_HTA[,cellGiottoMarkers[c(1,11,24,27,28,30)]])
cellGiottoMarkers <- cellGiottoMarkers[-which(cellGiottoMarkers %in% paste0('Median_Cell_', c('ACTININ', 'COX2', 'SNA', 'DAPI', 'CD45B', 'PDL1')))]
```


Perform normalization and subsample data to 10%. This code just sets it up. The subsetting is performed after plotting the histograms.
```{r subSample, fig.height=10, fig.width=10}
subsampPerc = 0.10
normalize=TRUE
# sample 20% from each slide region
slideObsN <- c(as.numeric(table(sc_HTA$Slide_Region)))
csObs <- c(0,cumsum(slideObsN))
HTA_sub <- NULL
set.seed(1)
for(i in 1:length(slideObsN)){
  news <- sample(slideObsN[i], ceiling(subsampPerc*slideObsN[i]))
  HTA_sub <- c(HTA_sub, (news+csObs[i]))
}

# normalizes using Cole's method else just log transforms
normedMarkers = paste0(cellGiottoMarkers, '_normed')
if(normalize){
  
  #slideMeans = as.data.frame(do.call(rbind, by(sc_HTA[,cellGiottoMarkers], sc_HTA$SlideID, colMeans)))
  #corrs = cor(slideMeans)
  #par(mar=c(15,15,15,15))
  #heatmap(corrs)
  
  sc_HTA[,normedMarkers ] = do.call(rbind, by(sc_HTA[,cellGiottoMarkers], sc_HTA$SlideID, function(slide){
    # SNV: added this to check if mean is zero
    cms= colMeans(slide[,cellGiottoMarkers])
    cms = ifelse(cms==0, 1, cms)
    log10(sweep(slide[,cellGiottoMarkers], 2, cms, FUN = '/') + 1)} ) )
} else {
  sc_HTA[,normedMarkers ] = do.call(rbind, by(sc_HTA[,cellGiottoMarkers], sc_HTA$SlideID, function(slide){
    log10(slide[,cellGiottoMarkers] + 1)} ) )
}
```


```{r histOverlays, fig.width=5, fig.height=5, eval=FALSE}
transpcols = col2rgb(cols)
transpcols = rgb(transpcols[1,], transpcols[2,], transpcols[3,], maxColorValue = 255, alpha = 20)
transpcols = rep(transpcols, 10)
#transpcols = rep(rgb(0, 0, 0, alpha=.05), 100)

slideIDs = unique(sc_HTA$SlideID)
invisible(sapply(normedMarkers,
               function(cellvar){
                 #layout(matrix(1:30, nrow=6, byrow=TRUE))
                 histinfo = hist(sc_HTA[sc_HTA[,cellvar]>0,cellvar], plot=FALSE)
                 meanZero = mean(c(by(sc_HTA[,cellvar]<=0, sc_HTA$SlideID, mean)))
                 hist(sc_HTA[sc_HTA$SlideID==slideIDs[1] & sc_HTA[,cellvar]>0,cellvar], breaks=histinfo$breaks, col=transpcols[1], border=NA, xlab=cellvar, probability = TRUE, ylim=c(0,3), main=cellvar) #
                 sapply(2:length(slideIDs), function(ind){
                   hist(sc_HTA[ sc_HTA$SlideID==slideIDs[ind]& sc_HTA[,cellvar]>0,cellvar], ylim=c(0,3), breaks = histinfo$breaks, border=NA, probability=TRUE, col=transpcols[ind], main=slideIDs[ind], xlab=cellvar, add=TRUE)
                 } )
                 legend('topright', legend=paste('Mean No. Zeros', round(meanZero, 2)), bty='n')
                 #mtext(cellvar, outer = TRUE, cex=1.5 )
                 #dev.new()
               }))
```

```{r histograms, fig.height=6, fig.width=6, eval=FALSE}
par(mfrow=c(2,2), mgp=c(1.6,0.8,0), lwd=1.5, lend=2, mar=c(3,3,1.8,0), bty='l', oma=c(0,0,0,0))
for(marker in c("Median_Cell_CD3D_normed", "Median_Cell_MUC5AC_normed", "Median_Cell_NAKATPASE_normed")){
  for(slideRegion in slideIDs[c(1,2,13,7)]){
    df= sc_HTA[sc_HTA$SlideID == slideRegion,]
    hist(df[,marker], main=df$SlideID[1], breaks=40, xlab=marker, cex.main=0.8)
  }
  for(slideRegion in slideIDs[c(1,2,13,7)]){
    df= sc_HTA[sc_HTA$SlideID == slideRegion,]
    hist(df[,marker][df[,marker]>log10(1)], main=df$SlideID[1], breaks=40, xlab=marker, cex.main=0.8)
  }
}
```

```{r histogramDensities, fig.height=6, fig.width=6, eval=FALSE}
par(mfrow=c(2,2), mgp=c(1.6,0.8,0), lwd=1.5, lend=2, mar=c(3,3,1.8,0), bty='l', oma=c(0,0,0,0))
cnstr <- list(
  'Median_Cell_CD3D_normed' = matrix(data=c(-Inf,0.4,0.4,Inf), nrow=2, byrow=TRUE),
  'Median_Cell_MUC5AC_normed' = matrix(data=c(-Inf,0.4,0.4,Inf), nrow=2, byrow=TRUE),
  'Median_Cell_NAKATPASE_normed' = matrix(data=c(-Inf,0.4,0.4,Inf), nrow=2, byrow=TRUE),
  'Median_Cell_CD4_normed' = matrix(data=c(-Inf,0.6,0.6,Inf), nrow=2, byrow=TRUE),
  'Median_Cell_CD8_normed' = matrix(data=c(-Inf,0.75,.75,Inf), nrow=2, byrow=TRUE),
  'Median_Cell_FOXP3_normed' = matrix(data=c(-Inf,0.75,.75,Inf), nrow=2, byrow=TRUE))
tables = lapply(cnstr, function(x) vector('list', length(slideIDs)))
tables = lapply(tables, function(x){names(x) = slideIDs; x})
for(marker in names(cnstr)){
  for(slideRegion in slideIDs){
    df= sc_HTA[sc_HTA$SlideID == slideRegion,]
    dat.col = df[,marker]
    non0 <- dat.col!=0
    dat_0rm <- dat.col[non0]
    fit <- cfGMM::cfGMM(dat_0rm, k=2, constraint=cnstr[[marker]], max.comp = FALSE)
    modes <- round(c(max(0,(fit$gamma.pars[1,1]-1)*fit$gamma.pars[2,1]),(fit$gamma.pars[1,2]-1)*fit$gamma.pars[2,2]),2)
    xs <- seq(from=0, to=max(dat_0rm), length.out=100)[-1]
    yline1 <- fit$lambda[1] * dgamma(xs, shape=fit$gamma.pars[1,1],scale=fit$gamma.pars[2,1])
    yline2 <- fit$lambda[2] * dgamma(xs, shape=fit$gamma.pars[1,2],scale=fit$gamma.pars[2,2])
    
    
    hist(dat.col[dat.col>0], main=df$SlideID[1], breaks=40, xlab=marker, cex.main=0.8, freq=FALSE)
    lines(xs, yline1, col=cols[1],lty=1,lwd=2)
    lines(xs, yline2, col=cols[3],lty=1,lwd=2)
    legend("topright",c('Unexpressed', 'Expressed'), col = cols[c(1,3)], lty = 1)
    tables[[marker]][[slideRegion]] = data.frame(Population=c('Background', 'Unexpressed', 'Expressed'),
               Proportions=round(c(1-mean(non0), fit$lambda*mean(non0)), 3),
               mode=c(NA,modes))
    # print(knitr::kable())
  }
  # if(!which(slideIDs %in% slideRegion) %% 4){
  #   mtext(marker,outer = TRUE)
  # }
}
```

```{r boxplotSSL, fig.width=3, fig.height=3, eval=FALSE}

tumorTab = data.frame(muc5ac = sapply(tables$Median_Cell_MUC5AC_normed, function(x) x[3,2]), tumorType = factor(c(by(sc_HTA$lessBroad, sc_HTA$SlideID, function(x) x[1]))) )
par(mfrow=c(1,1), mgp=c(1.6,0.8,0), lwd=1.5, lend=2, mar=c(3,3,1.8,0), bty='l', oma=c(0,0,0,0))
boxplot(log10(muc5ac)~tumorType, data=tumorTab, bty='n', ylab='log10(MUC5AC)', xlab='Tumor Type')

```



```{r histogramMixtoolsDensities, fig.height=6, fig.width=6, eval=FALSE}
par(mfrow=c(2,2), mgp=c(1.6,0.8,0), lwd=1.5, lend=2, mar=c(3,3,1.8,0), bty='l', oma=c(0,0,0,0))
for(marker in names(cnstr)){
  for(slideRegion in slideIDs){
    df= sc_HTA[sc_HTA$SlideID == slideRegion,]
    dat.col = df[,marker]
    non0 <- dat.col!=0
    dat_0rm <- dat.col[non0]
    fit <- mixtools::gammamixEM(dat_0rm, k=2)
    modes <- round(c(max(0,(fit$gamma.pars[1,1]-1)*fit$gamma.pars[2,1]),(fit$gamma.pars[1,2]-1)*fit$gamma.pars[2,2]),2)
    xs <- seq(from=0, to=max(dat_0rm), length.out=100)[-1]
    yline1 <- fit$lambda[1] * dgamma(xs, shape=fit$gamma.pars[1,1],scale=fit$gamma.pars[2,1])
    yline2 <- fit$lambda[2] * dgamma(xs, shape=fit$gamma.pars[1,2],scale=fit$gamma.pars[2,2])
    
    
    hist(dat.col[dat.col>0], main=df$Slide_Region[1], breaks=40, xlab=marker, cex.main=0.8, freq=FALSE)
    lines(xs, yline1, col=cols[1],lty=1,lwd=2)
    lines(xs, yline2, col=cols[3],lty=1,lwd=2)
    legend("topright",c('Unexpressed', 'Expressed'), col = cols[c(1,3)], lty = 1)
    # print(knitr::kable(data.frame(Population=c('Background', 'Unexpressed', 'Expressed'),
    #            Proportions=round(c(1-mean(non0), fit$lambda*mean(non0)), 3),
    #            mode=c(NA,modes))))
  }
}
```

```{r ggImages, fig.height=12, fig.width=12, eval=FALSE}
par(mfrow=c(1,1), mgp=c(1.6,0.8,0), lwd=1.5, lend=2, mar=c(3,3,1.8,0), bty='l', oma=c(0,0,0,0))
slideRegions = unique(sc_HTA$Slide_Region)
for(marker in "Median_Cell_MUC5AC_normed"){
  for(slideRegion in slideRegions){
    df= sc_HTA[sc_HTA$Slide_Region == slideRegion,]
    dat.col = df[,marker]
    non0 <- dat.col!=0
    dat_0rm <- dat.col[non0]
    fit <- cfGMM::cfGMM(dat_0rm, k=2, constraint=cnstr[[marker]], max.comp = FALSE)
    
    redyellow = colorRampPalette(c('red', 'yellow'), space='Lab')
    plot.df <- df[,c("epi","x","y")]
    plot.df$expressed = 0
    plot.df$expressed[non0] = fit$posterior[,2]
    plot.df$expressed[plot.df$expressed<0.25] = 0
    #plot.df$expressed[plot.df$expressed<0.5] = 0
    #viewMoranDisc(list(sr$CD8[i]), R=100, plot.df=plot.df, SR=slidename)
    grayscale_colors <- gray.colors(100,            # number of different color levels
                                    start = 0.0,    # how black (0) to go
                                    end = 1.0,      # how white (1) to go
                                    gamma = 2.2,    # correction between how a digital
                                    # camera sees the world and how human eyes see it
                                    alpha = NULL)
    markername=gsub('Median_Cell_|_normed', '', marker)
    ras = raster(sr[ sr$slide_region==slideRegion, markername])
    plot(ras, col=grayscale_colors, main=slideRegion, axes=FALSE, legend=FALSE)
    points(plot.df$x*.99,(dim(ras)[1]-plot.df$y)*.99, pch=1, cex=0.25, col=redyellow(64)[cut(plot.df$expressed, breaks=seq(-0.01,1, length.out=64), labels=FALSE)])
    
    ras = raster(sr[ sr$slide_region==slideRegion, 'BCATENIN'])
    plot(ras, col=grayscale_colors, main=slideRegion, axes=FALSE, legend=FALSE)
    points(plot.df$x*.99,(dim(ras)[1]-plot.df$y)*.99, pch=1, cex=0.25, col=redyellow(64)[cut(plot.df$expressed, breaks=seq(0,1, length.out=64), labels=FALSE)])
  }
}
```


```{r subset}
# subsets after normalization
sc_HTAfull = sc_HTA
sc_HTA <- sc_HTA[HTA_sub,]
```



Takes very long to run, result saved in rdata. After running the first clustering, get the clustering results from resolution=0.01 and run at higher resolution within those clusters. In the Epi label below, 2 is epithelial cells.



This is the same process as we did with Giotto, but performed in Seurat.
```{r cellClusteringHTAseurat, fig.height=8, fig.width=10}
library(Seurat)
if(normalize){
  giottoClusterData_HTAreslow = '../data/seuratClustering_normalized.rdata'
} else {
  giottoClusterData_HTAreslow = '../dataseuratClustering_raw.rdata'
}
if(!file.exists(giottoClusterData_HTAreslow)){
  obj<-CreateSeuratObject(counts=t(sc_HTA[,normedMarkers]))
  #obj<-ScaleData(obj,features=rownames(obj),verbose=F)
  obj<-FindNeighbors(obj,features=rownames(obj),dims=NULL, k.param=150, compute.SNN=TRUE)
  
  # perform Leiden clustering
  obj<-FindClusters(obj,verbose = F, algorithm = 4, resolution=0.1, method='igraph')
  # perform 
  
  
  # visualize results
  #obj<-ScaleData(obj,features=rownames(obj),verbose=F)
  #obj@assays$RNA@scale.data = obj@assays$RNA@data
  # scaling doesn't look as good
  #sobj<-RunUMAP(obj, features=rownames(obj), slot='scale.data')
  #DimPlot(sobj, reduction = "umap", pt.size=0.01)+NoLegend()
  obj<-RunUMAP(obj, features=rownames(obj), slot='data')
  DimPlot(obj, reduction = "umap", pt.size=0.01)+NoLegend()
  #obj[["x"]]<-regiondata$Cell_Centroid_X
  #obj[["y"]]<-regiondata$Cell_Centroid_Y
  # visualize the results
  
  # perform subclustering
  obj = FindSubCluster(obj, cluster=1, algorithm = 4, resolution=1, graph.name='RNA_snn')
  obj = FindSubCluster(obj, cluster=2, algorithm = 4, resolution=1, graph.name='RNA_snn', subcluster.name='sub.cluster2')
  
  save(obj, file=giottoClusterData_HTAreslow)
}


load(giottoClusterData_HTAreslow)
obj$sub.cluster = ifelse(obj$seurat_clusters==1, obj$sub.cluster, obj$sub.cluster2)

Idents(obj) = obj$sub.cluster
pb = capture.output(markers<-FindAllMarkers(obj, slot='counts', features=rownames(obj), only.pos = TRUE))
HMdata = reshape(markers[, c('cluster', 'gene', 'avg_log2FC')], direction='wide', idvar='cluster', timevar='gene' )
HMdata[is.na(HMdata)] = 0
rownames(HMdata) = HMdata[,1]
colnames(HMdata) = gsub('avg_log2FC.Median-Cell-|-normed', '', colnames(HMdata))
```


```{r, plotClustering, fig.height=8, fig.width=10}
  DimPlot(obj , reduction = "umap", group.by='sub.cluster', pt.size=0.01, label=TRUE)+NoLegend()
  #
  heatmap(  as.matrix(HMdata[,-1]) )
  HMdata2 = do.call(rbind, by(t(obj@assays$RNA@data), obj$sub.cluster, colMeans))
  colnames(HMdata2) = gsub('Median-Cell-|-normed', '', colnames(HMdata2))
  heatmap(  as.matrix(HMdata2[,-1]) )
  
  labels = read.csv('../data/annotations.csv')
  labels$label = gsub('\\?', '', labels$label)
  
  obj$label = obj$sub.cluster
  obj$label = labels$label[match(obj$label, labels$cID)]
  obj$label[ is.na(obj$label) ] = obj$sub.cluster[ is.na(obj$label)]
  Idents(obj) = obj$label
  
  DimPlot(obj , reduction = "umap", group.by='label', pt.size=0.01, label=TRUE)+NoLegend()
  #knitr::kable(labels)
```


Here, we predict the labels in the part of the dataset where clustering was not performed.

```{r predictLabels, eval=TRUE}
# Get other set of data into seurat format
test.obj = CreateSeuratObject(counts=t(sc_HTAfull[ -HTA_sub, normedMarkers]))

sc_HTA$label = factor(obj$label[ match(rownames(sc_HTA), colnames(obj))])
rf = randomForest(sc_HTA[,normedMarkers], sc_HTA$label, ntree=1000)
sc_HTAfull$label = NA
sc_HTAfull$label[ HTA_sub] = sc_HTA$label
sc_HTAfull$label[ -HTA_sub] = predict(rf, sc_HTAfull[ -HTA_sub, normedMarkers])
sc_HTAfull$label = levels(factor(sc_HTA$label))[sc_HTAfull$label]
sc_HTAfull$label = factor(sc_HTAfull$label)

# Find anchors. Used to match data
#anchors = FindTransferAnchors(reference = obj, query = test.obj, scale=FALSE, features=rownames(obj), reference.assay = 'RNA', npcs = 25, dims=1:25)
#predictions = TransferData(anchorset = anchors, refdata = obj$celltype, dims = 1:30)
#test.obj <- AddMetaData(object = test.obj, metadata = predictions)
save(list=c('sr', 'sc_HTAfull', 'sc'), file='/media/disk2/atlas_mxif/data/cell_phenotyped.rds')
```



### Results: low resolution {.tabset}

This is the results displayed for each slide.
```{r, results='asis', fig.height=9, fig.width=9, eval=FALSE, cache=TRUE}
lhta = length(unique(sc_HTAfull$Slide_Region))
for(i in 1:lhta){
  slre <- unique(sc_HTAfull$Slide_Region)[i]
  cat('\n####', slre, '\n')
  

  scsubset = sc_HTAfull[sc_HTAfull$Slide_Region==slre, ]
  oldpar = par(mar=c(0,0,3,4.5), mfrow=c(1,1), oma=c(0,0,0.5,0), mgp=c(2,1,0))
  for(marker in c('BCATENIN')){ #'COLLAGEN', 'PANCK', 'PCNA', 'CD3D'
    imgname=sr[ sr$slide_region==slre, marker]
    if(!is.na(imgname) & file.exists(imgname)){
      #titl = paste(srHTA[i+1], marker)
      ras = raster(imgname)
      pinfo = plot(ras,
           col = grayscale_colors,
           axes = FALSE,
           main = marker, bty='n', cex.main=.7, legend=FALSE)
      points(scsubset$x-1, dim(ras)[1]-scsubset$y, col=Polychrome::alphabet.colors()[as.numeric(as.factor(scsubset$label))], pch=16, cex=.25 )
par(mar=c(4,15,4,2))
barplot(rep(1, nlevels(sc_HTAfull$label)), names.arg=levels(sc_HTAfull$label), col=Polychrome::alphabet.colors()[1:nlevels(sc_HTAfull$label)], las=2, horiz=TRUE)
    }
  }
  par(oldpar)
  cat('\n\n')
  
  # oldpar = par(mar=c(0,0,3,4.5), mfrow=c(3,3), oma=c(0,0,0.5,0), mgp=c(2,1,0))
  # for(marker in allMarkers){
  #   imgname=sr[ sr$slide_region==slre, marker]
  #   if(!is.na(imgname) & file.exists(imgname)){
  #     #titl = paste(srHTA[i+1], marker)
  #     ras = raster(imgname)
  #     plot(ras,
  #          col = grayscale_colors,
  #          axes = FALSE,
  #          main = marker, bty='n', cex.main=.7)}
  # }
  # par(oldpar)
  cat('\n\n')
}
```
